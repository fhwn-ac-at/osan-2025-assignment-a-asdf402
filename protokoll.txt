Das im Unterricht erstellte Programm simuliert eine kleine Arbeitswelt:
Der Hauptprozess („Chef“) startet 10 Kindprozesse („Arbeiter“) und gibt ihnen über eine Nachrichtenwarteschlange Anweisungen, wie lange sie „arbeiten“ sollen (sie schlafen dafür ein paar Sekunden). Jeder Arbeiter holt sich seinen Auftrag aus der Queue, arbeitet (also schläft), meldet sich dann zurück und beendet sich. Der Chef wartet geduldig auf alle Rückmeldungen, überprüft, ob alles glatt lief, und räumt am Ende alles ordentlich auf. Ein Kommandozeilenparser ist auch schon vorbereitet, wird aber aktuell noch nicht verwendet.

Der neue Code verwendet viele Grundlagen aus dem alten Programm wieder. Zum Beispiel wird erneut mit POSIX Message Queues gearbeitet (mq_open, mq_send, mq_receive) und Prozesse werden mit fork() gestartet. Auch die Art, wie Fehler behandelt und Zeitstempel für Ausgaben erzeugt werden, ist ähnlich geblieben.

Neu hinzugekommen ist beispielsweise die Kommunikation wurde erweitert – Worker senden ihre Ergebnisse über eine eigene Queue zurück. Damit das zuverlässig funktioniert, wurden extra Funktionen geschrieben, die auch bei Unterbrechungen (EINTR) korrekt weitermachen. Außerdem ist der Code klarer strukturiert: Der Ventilator und die Worker haben jeweils eigene Funktionen. Auch die Übergabe und Prüfung der Programmargumente wurde verbessert. Ein cleverer Zusatz ist die dynamische Vergabe von Queue-Namen mit getpid(), um Konflikte bei mehreren Programmläufen zu vermeiden.

Schwierig war vor allem, die Kommunikation zwischen den Prozessen zuverlässig hinzubekommen. Es musste genau überlegt werden, wann Nachrichten geschickt und empfangen werden, damit nichts verloren geht. Auch das saubere Beenden der Worker und das Einsammeln aller Rückmeldungen hat etwas Geduld und gutes Timing gebraucht.
